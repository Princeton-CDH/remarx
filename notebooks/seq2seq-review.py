

import marimo

__generated_with = "0.13.3"
app = marimo.App(width="full", css_file="highlight.css")


@app.cell
def _():
    import marimo as mo
    return (mo,)


@app.cell(hide_code=True)
def _(mo):
    mo.md(r"""# Review seq2seq results in context""")
    return


@app.cell
def _():
    import polars as pl
    return (pl,)


@app.cell
def _(pl):
    import pathlib

    seq2seq_data_dir = pathlib.Path("data/seq2seq/1896-97aCLEAN_parts_output")

    quotes_df = pl.read_csv(seq2seq_data_dir / "quotes.csv")
    quotes_df
    return pathlib, quotes_df, seq2seq_data_dir


@app.cell(hide_code=True)
def _(mo):
    mo.md(
        r"""
        ## Adjust offsets to match annotated text files

        `seq2seq` can't handle longer files (memory limitations). For convenience, I fed it the articles that were split out from the first set of "cleaned" texts. If we can find the offset of these files in the cleaned text they come from, then we can adjust offsets and look at the quotation data in context â€” hopefully there are a few adjacent to annotated data.

        Get a list of unique files referenced in the quotation data:
        """
    )
    return


@app.cell
def _(mo, pathlib, pl, seq2seq_data_dir):
    input_offset_file = seq2seq_data_dir / "input_offsets.csv"

    if not input_offset_file.exists():
        print(
            f"Input offset file {input_offset_file} not found, determining offsets."
        )

        chunked_file_dir = pathlib.Path(
            "data/neue-zeit-full_transcriptions/1896-97aCLEAN_parts/"
        )
        chunk_info = []
        offset = 0
        for txtfile in sorted(chunked_file_dir.glob("*.txt")):
            file_length = len(txtfile.open().read())
            chunk_info.append(
                {
                    "file": txtfile.name,  # match filename in quotes.csv generated by seq2seq
                    "file_offset": offset,
                    "file_length": file_length,
                }
            )
            offset += file_length

        input_offset_df = pl.from_dicts(chunk_info)
        input_offset_df.write_csv(input_offset_file)
    else:
        print(
            f"Loading previously calculated input file source offsets from {input_offset_file}."
        )
        input_offset_df = pl.read_csv(input_offset_file)

    mo.ui.table(input_offset_df, selection=None)
    return (input_offset_df,)


@app.cell
def _(input_offset_df, quotes_df):
    # join seq2seq quotes data with input file offsets so we can calculate offset in the annotated file

    quotes_source_text = quotes_df.join(input_offset_df, on="file")
    quotes_source_text
    return (quotes_source_text,)


@app.cell
def _(pl, quotes_source_text):
    # adjust offsets to match annotated file
    from intspan import intspan


    # use intspan to parse and adjust by file offset and then serialize back to a span
    def adjust_span_offset(span, adjustment):
        span = intspan(
            span.replace(";", ",")
        )  # replace ; with , so intspan can parse ranges
        # adjust all values
        adjusted_span = intspan([i + adjustment for i in list(span)])
        return str(adjusted_span)


    # use intspan to parse and get first offset value
    def first_offset(span):
        return list(intspan(span))[0]


    # df.select([pl.struct(["ham", "spam", "foo"]).apply(my_complicated_function)])

    # start with quote offsets and then figure out which others we need
    adjusted_offsets = quotes_source_text.select(
        pl.col("quote_offsets", "file_offset")
    ).map_rows(
        lambda row: adjust_span_offset(row[0], row[1]), return_dtype=pl.String
    )

    quotes_adjusted = quotes_source_text.with_columns(
        quote_offsets_adjusted=pl.Series(adjusted_offsets),
        quote_offset_start=pl.Series(adjusted_offsets).map_elements(
            first_offset, return_dtype=pl.Int32
        ),
    )
    quotes_adjusted
    return adjust_span_offset, intspan, quotes_adjusted


@app.cell
def _(pl):
    # load quote annotations test subset
    # - filter to the file we ran seq2seq on
    quote_annotations = pl.read_csv("data/direct_quotes_subset.csv").filter(
        pl.col("FILE").eq("1896-97aCLEAN.txt")
    )
    quote_annotations
    return (quote_annotations,)


@app.cell
def _():
    # get a unique list of pages from quote annotations (some pages have multiple quotes)
    # then do a conditional join with seq2seq quotes to find a page where we have examples of both
    # once we have that subset, display side by side
    return


@app.cell
def _(pl, quote_annotations):
    # get a unique list of pages from quote annotations (some pages have multiple quotes)
    annotation_pages = quote_annotations.select(
        pl.col("page_index", "page_text", "page_start", "page_end")
    ).unique()
    annotation_pages
    return (annotation_pages,)


@app.cell
def _(adjust_span_offset, annotation_pages, mo, pl, quotes_adjusted):
    # do a conditional join of annotation pages with seq2seq quotes to find a page where we have examples of both
    quotes_pages = quotes_adjusted.join_where(
        annotation_pages,
        pl.col("quote_offset_start") >= pl.col("page_start"),
        pl.col("quote_offset_start") < pl.col("page_end"),
    )

    # start with quote offsets and then figure out which others we need
    # adjusted_offsets = quotes_source_text.select(
    #     pl.col("quote_offsets", "file_offset")
    # ).map_rows(
    #     lambda row: adjust_span_offset(row[0], row[1]), return_dtype=pl.String
    # )

    # adjust quote offset to make them relative to the page using page start
    page_offsets = quotes_pages.select(
        pl.col("quote_offsets_adjusted", "page_start")
    ).map_rows(lambda row: adjust_span_offset(row[0], -row[1]))

    quotes_pages = quotes_pages.with_columns(
        quote_offsets_page=pl.Series(page_offsets)
    ).sort("quote_offset_start")  # sort by order in the file

    mo.ui.table(quotes_pages, page_size=15, selection=None)
    return (quotes_pages,)


@app.cell
def _(intspan):
    def highlight_spans(text: str, spans: str):
        spans = intspan(spans)
        previous_end = 0
        text_parts = []
        for start, end in spans.ranges():
            # text before the mark
            text_parts.append(text[previous_end:start])
            # text to be highlighted
            text_parts.append(f"<mark>{text[start:end]}</mark>")
            # set previuos end to the portion after this span
            previous_end = end
        # append any text after the last highlighted portion
        text_parts.append(text[previous_end:])
        return "".join(text_parts)
        # return f"<div>{before}<span class='hi'>{span}</span>{after}</div>"
    return (highlight_spans,)


@app.cell
def _(highlight_spans, mo, quote_slider, quotes_pages):
    def display_seq2seq_page(quote):
        quote_info = {
            field: quote[field]
            for field in ["type", "speaker", "cue", "addressee"]
            if quote[field]
        }
        quote_info_string = (
            "<dl>"
            + " ".join(
                f"<dt>{field}</dt><dd>{value}</dd>"
                for field, value in quote_info.items()
            )
            + "</dl>"
        )

        return mo.Html(
            "<section class='page'><header><h1>seq2seq quote</h2>"
            + quote_info_string
            + f"<p class='info'>page index {quote['page_index']}</p></header>"
            + highlight_spans(quote["page_text"], quote["quote_offsets_page"])
            + "</section>",
        )
        # page_start_index, page_end_index = (
        #     quote["start_index"] - quote["page_start"],
        #     quote["end_index"] - quote["page_start"],
        # )
        # before_quote = quote["page_text"][0:page_start_index]
        # quote_text = quote["page_text"][page_start_index:page_end_index]
        # after_quote = quote["page_text"][page_end_index:]

        # return mo.Html(f"""
        # <p>Page index: {quote["page_index"]} (article: {page_start_index}:{page_end_index} page: {page_start_index}:{page_end_index})</p>

        # <div class='span-compare'>
        # <div>{before_quote}<span class='hi'>{quote_text}</span>{after_quote}</div>
        # </div>
        # """)


    def current_seq2seq_page():
        return display_seq2seq_page(
            quotes_pages.row(quote_slider.value, named=True)
        )


    current_seq2seq_page()
    return (current_seq2seq_page,)


@app.cell(hide_code=True)
def _(pl, quote_annotations):
    # calculate page offsets, then turn into span
    quote_page_spans = (
        quote_annotations.with_columns(
            start_index=pl.col("start_index").sub(pl.col("page_start")),
            end_index=pl.col("end_index").sub(pl.col("page_start")),
        )
        .with_columns(
            page_span=pl.concat_str(
                [pl.col("start_index"), pl.col("end_index")], separator="-"
            )
        )
        .select(
            pl.col("page_index", "page_span", "page_text"),
        )  # limit to just page index and quote span on the page
        .group_by("page_index")  # group by pages
        .all()
    )

    quote_page_spans = quote_page_spans.with_columns(
        page_span=pl.col("page_span").list.join(
            ","
        ),  # combine multiple page spans
        page_text=pl.col("page_text").list.first(),
    )

    quote_page_spans
    return (quote_page_spans,)


@app.cell(hide_code=True)
def _(highlight_spans, mo, pl, quote_page_spans, quote_slider, quotes_pages):
    # try annotation + seq2seq side by side


    def display_annotation_page(annotation_page):
        text = highlight_spans(
            annotation_page["page_text"], annotation_page["page_span"]
        )

        return mo.Html(f"""<section class='page'><header><h1>annotated quote</h2>
        <p class='info'>page index {annotation_page["page_index"]}</p></header>
        {text}
        </section>""")

        # + highlight_spans(quote["page_text"], quote["quote_offsets_page"])
        # + "</section>",

        #     f"""
        # <p>Page index: {quote["page_index"]} (article: {page_start_index}:{page_end_index} page: {page_start_index}:{page_end_index})</p>

        # <div class='span-compare'>
        # <div>{before_quote}<span class='hi'>{quote_text}</span>{after_quote}</div>
        # </div>
        # """)


    def current_selected_annotation():
        # get page index from quote pages row
        page_index = quotes_pages.row(quote_slider.value, named=True)["page_index"]
        # get annotation page by page index with text and spans as dict
        annotation_page = quote_page_spans.filter(
            pl.col("page_index").eq(page_index)
        ).row(0, named=True)

        return display_annotation_page(annotation_page)


    current_selected_annotation()
    return (current_selected_annotation,)


@app.cell(hide_code=True)
def _(mo, quotes_pages):
    quote_slider = mo.ui.slider(
        start=0,
        stop=quotes_pages.height - 1,
        step=1,
        label="Quote",
    )

    mo.vstack(
        [
            quote_slider,
            mo.md("Move the slider to change which quote is displayed."),
        ]
    )
    return (quote_slider,)


@app.cell
def _(current_selected_annotation, current_seq2seq_page, mo):
    mo.hstack(
        [current_selected_annotation(), current_seq2seq_page()],
    )
    return


if __name__ == "__main__":
    app.run()
