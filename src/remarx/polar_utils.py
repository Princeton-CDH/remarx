import csv
from collections import defaultdict

import polars as pl


def load_title_phrases(filename: str) -> dict[str, list[str]]:
    """
    Load title phrases from file. Returns a dictionary mapping
    a title (e.g., "Kapital") to a list of its search phrases
    used for identifying candidate sentences.
    """
    title_phrases = defaultdict(list)
    with open(filename, encoding="utf-8-sig", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            title_phrases[row["title"]].append(row["phrase"])
    return title_phrases


def load_candidate_sentences(
    filename: str, title_phrases: dict[str, str]
) -> pl.DataFrame:
    """
    Load candidate sentences from a CSV file and prepare a dataframe for combination with other data. Expects a CSV file generated by `candidate_mentions` script. Constructs a sentence id field and adds fields indicating which titles each sentence is a candidate for, based on the title phrase lookup passed in.
    """
    # Load initial data
    df = pl.read_csv(filename)

    # Initial field munging
    df = df.with_columns(
        [
            # Create sentence id
            pl.concat_str(
                pl.col("file"),
                pl.col("sent_idx"),
                separator=":",
            ).alias("sent_id"),
            # Create starting index
            pl.col("char_idx").alias("start_idx"),
            # Create phrase list from phrases column
            pl.col("phrases").str.split(" | ").alias("phrase_list"),
        ]
    )

    # Construct additional fields, dependent on previous step
    df = df.with_columns(
        [
            # Compute ending index
            (pl.col("start_idx") + pl.col("sentence").str.len_chars()).alias("end_idx"),
            # Determine if sentence is a title candidate by check for a title's phrases
            ## Determine if sentence is a candidate for Das Kapital
            (
                (
                    pl.col("phrase_list").list.set_intersection(
                        title_phrases["Kapital"]
                    )
                ).list.len()
                > 0
            ).alias("kapital_candidate"),
            ## Determine if sentence is a candidate for the Communist Manifesto
            (
                (
                    pl.col("phrase_list").list.set_intersection(
                        title_phrases["Manifesto"]
                    )
                ).list.len()
                > 0
            ).alias("manifest_candidate"),
        ]
    )
    return df


# TODO: Rename method
def join_candidates_annotation(
    candidate_sentences_df: pl.DataFrame, annotations_df: pl.DataFrame
) -> pl.DataFrame:
    """
    Adds title mention annotations to candidate sentences dataframe. For a given
    sentence without an annotation, the following values are set:
        * uiud: "N/A"
        * anno_start_idx: -1
        * anno_end_idx: -1
        * mentions_kapital: "No"
        * mentions_manifest: "No"
    """
    # Sentences with annotations
    annotated_sents = (
        # Find sentences that overlap with annotations
        candidate_sentences_df.join_where(
            annotations_df,
            pl.col("file") == pl.col("file_right"),
            pl.col("start_idx") < pl.col("end_idx_right"),
            pl.col("start_idx_right") < pl.col("end_idx"),
        )
        .rename(
            {
                "start_idx_right": "anno_start_idx",
                "end_idx_right": "anno_end_idx",
            }
        )
        .drop("file_right")
    )

    # Sentences without annotations
    unannotated_sents = candidate_sentences_df.filter(
        ~pl.col("sent_id").is_in(annotated_sents.get_column("sent_id").to_list())
    ).with_columns(
        # add annotation-related columns
        pl.lit("N/A").alias("uuid"),
        pl.lit(-1, dtype=pl.datatypes.Int64).alias("anno_start_idx"),
        pl.lit(-1, dtype=pl.datatypes.Int64).alias("anno_end_idx"),
        pl.lit("No").alias("mentions_kapital"),
        pl.lit("No").alias("mentions_manifest"),
    )

    return annotated_sents.vstack(unannotated_sents).sort(["file", "sent_idx"])
